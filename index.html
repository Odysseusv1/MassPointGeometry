<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mass Point Geometry</title>

<style>
body {
    font-family: Arial, sans-serif;
    background: #f4f6f8;
    text-align: center;
    padding: 20px;
}
button {
    padding: 10px 18px;
    margin: 6px;
    font-size: 16px;
}
canvas {
    background: white;
    border: 2px solid #333;
    margin-top: 20px;
}
.page {
    display: none;
    max-width: 900px;
    margin: auto;
}
.active {
    display: block;
}
p, li {
    text-align: left;
    line-height: 1.6;
    font-size: 17px;
}
.info {
    margin-top: 20px;
    font-size: 17px;
}
</style>
</head>

<body>

<h1>My Nueva Project: Mass Point Geometry</h1>
<br>
<br>
<button onclick="showPage('about')">About</button>
<button onclick="showPage('line')">Line Demo</button>
<button onclick="showPage('triangle')">Triangle Demo</button>
<button onclick="showPage('explain')">Explanation</button>

<div id="about" class="page active">
<h2><b>Inspiration</b></h2>
<p>I was inspired by problem 24 from the 2019 AMC 8. In triangle ABC, point D divides side AC such that AD:DC = 1:2. Let E be the midpoint of BD and let F be the point of intersection of line BC and line AE. Given that the area of △ABC is 360, what is the area of triangle △EBF?</p>
<p>This problem initially seemed scary, coordinate geometry would be difficult, and calculating areas directly felt complicated. Much later, I discovered that mass point geometry provided an elegant solution. By assigning masses to the vertices, the ratios and areas fell into place naturally. This experience showed me the power of choosing right method for a problem, and it inspired me to build this interactive demonstration to help others understand and appreciate this beautiful technique.</p>
<p>This problem showcases how mass point geometry can elegantly solve what might otherwise require coordinate geometry or complex area calculations.</p>
<h2><b>Process</b> </h2>
<p>I started by understanding mass point geometry through the AMC 8 problem. My process involved three key steps:</p>
<ol>
    <li><b>Research & Theory:</b> I studied how assigning masses to vertices creates balance points, and how ratios on sides relate inversely to masses.</li>
    <li><b>Interactive Visualization:</b> I built two demos—one showing how masses determine a point's position on a line segment, and another demonstrating how three concurrent cevians work in a triangle.</li>
    <li><b>Implementation:</b> I used HTML5 Canvas for rendering, mouse event listeners for interactivity, and mathematical functions to ensure geometric correctness.</li>
</ol>
<h2><b>What I learned</b></h2>
<p>Mass point geometry is a powerful technique for solving problems involving ratios and areas in triangles. It allows for elegant solutions by assigning "masses" to vertices, which then determine the positions of points on segments and the relationships between areas.</p>
<p>This process also taught me about coding and how to implement mathematical concepts in an interactive environment.</p>
</div>
<div id="line" class="page">
<h2>Mass Points on a Line</h2>
<p>Drag point <b>D</b> along segment <b>BC</b>.</p>

<canvas id="lineCanvas" width="600" height="200"></canvas>

<div class="info">
<p><b>BD : DC</b> = <span id="lineRatio"></span></p>
<p><b>Mass at B</b> = <span id="massB"></span></p>
<p><b>Mass at C</b> = <span id="massC"></span></p>
<p><b>Mass at D</b> = <span id="massD"></span></p>
</div>
</div>

<div id="triangle" class="page">
<h2>Triangle with True Concurrent Cevians</h2>
<p>
Drag point <b>P</b>.  
It always stays <b>inside the triangle</b>, and every cevian
passes through <b>P</b> and hits the opposite side.
</p>

<canvas id="triCanvas" width="600" height="420"></canvas>

<div class="info">
<p><b>BD : DC</b> = <span id="rBC"></span></p>
<p><b>CE : EA</b> = <span id="rCA"></span></p>
<p><b>AF : FB</b> = <span id="rAB"></span></p>
</div>
</div>

<div id="explain" class="page">
<h2>Why This Is Guaranteed Correct</h2>
<h3>The Law of Lever</h3>
<p>Mass point geometry is based on the <b>law of lever</b> from physics. If two masses are balanced on a lever (seesaw) around a fulcrum, then:</p>
<p style="text-align: center; font-size: 18px;"><b>Mass₁ × Distance₁ = Mass₂ × Distance₂</b></p>
<p>Equivalently, if point <b>D</b> divides segment <b>BC</b> such that <b>BD : DC = m_C : m_B</b>, then assigning mass <b>m_B</b> at B and mass <b>m_C</b> at C makes D the balance point. The mass at the fulcrum D is simply <b>m_B + m_C</b>.</p>

<h3>Cevians and Concurrent Lines</h3>
<p>A <b>cevian</b> is a line segment from a vertex of a triangle to a point on the opposite side. When you assign masses to the three vertices A, B, and C, each side finds its balance point (fulcrum), and the three cevians from vertices through these balance points all meet at a single point—called the <b>concurrent point</b>.</p>
<p>This is guaranteed by <b>Ceva's Theorem</b>: if cevians AD, BE, and CF are concurrent at point P, then the product of the three ratios equals 1.</p>

<h3>Why It Works</h3>
<p>When you drag point P in the triangle demo, the interactive visualization assigns masses to A, B, and C such that:</p>
<ul>
    <li>Point D on BC balances masses at B and C</li>
    <li>Point E on CA balances masses at C and A</li>
    <li>Point F on AB balances masses at A and B</li>
</ul>
<p>Because the masses are consistent across all three vertices, all three cevians pass through the same point P. No special calculations needed—the physics of the lever guarantees it!</p>
</div>

<script>
function showPage(id) {
    document.querySelectorAll(".page").forEach(p => p.classList.remove("active"));
    document.getElementById(id).classList.add("active");
}

const lc = document.getElementById("lineCanvas");
const lctx = lc.getContext("2d");

const LB = { x: 100, y: 100 };
const LC = { x: 500, y: 100 };
let LD = { x: 300, y: 100 };
let dragLine = false;

function drawLine() {
    lctx.clearRect(0,0,lc.width,lc.height);

    drawSeg(LB,LC,lctx);
    drawDot(LB,"B",lctx);
    drawDot(LC,"C",lctx);
    drawDot(LD,"D",lctx,true);

    const BD = LD.x - LB.x;
    const DC = LC.x - LD.x;
    const g = gcd(BD,DC);

    document.getElementById("lineRatio").textContent = `${BD/g} : ${DC/g}`;
    document.getElementById("massB").textContent = DC/g;
    document.getElementById("massC").textContent = BD/g;
    document.getElementById("massD").textContent = BD/g + DC/g;
}

lc.addEventListener("mousedown",e=>{
    if(Math.abs(e.offsetX-LD.x)<10) dragLine=true;
});
lc.addEventListener("mousemove",e=>{
    if(!dragLine) return;
    LD.x=Math.max(LB.x,Math.min(LC.x,e.offsetX));
    drawLine();
});
lc.addEventListener("mouseup",()=>dragLine=false);

const tc = document.getElementById("triCanvas");
const ctx = tc.getContext("2d");

const A = { x: 300, y: 60 };
const B = { x: 120, y: 340 };
const C = { x: 480, y: 340 };

let P = { x: 300, y: 220 };
let draggingP = false;

function dist(p,q){ return Math.hypot(p.x-q.x,p.y-q.y); }

/* Barycentric coordinates */
function barycentric(P,A,B,C){
    const det =
        (B.y-C.y)*(A.x-C.x) +
        (C.x-B.x)*(A.y-C.y);
    const l1 =
        ((B.y-C.y)*(P.x-C.x) +
         (C.x-B.x)*(P.y-C.y)) / det;
    const l2 =
        ((C.y-A.y)*(P.x-C.x) +
         (A.x-C.x)*(P.y-C.y)) / det;
    const l3 = 1 - l1 - l2;
    return {l1,l2,l3};
}

// Clamp P to inside triangle ABC
function clampToTriangle(P){
    let {l1,l2,l3} = barycentric(P,A,B,C);

    l1 = Math.max(0,l1);
    l2 = Math.max(0,l2);
    l3 = Math.max(0,l3);

    const s = l1 + l2 + l3;
    return {
        x:(l1*A.x + l2*B.x + l3*C.x)/s,
        y:(l1*A.y + l2*B.y + l3*C.y)/s
    };
}

// Line Intersection
function intersect(U,V,X,Y){
    const a1 = V.y - U.y;
    const b1 = U.x - V.x;
    const c1 = a1*U.x + b1*U.y;

    const a2 = Y.y - X.y;
    const b2 = X.x - Y.x;
    const c2 = a2*X.x + b2*X.y;

    const det = a1*b2 - a2*b1;
    return {
        x:(b2*c1 - b1*c2)/det,
        y:(a1*c2 - a2*c1)/det
    };
}


function drawTriangle(){
    ctx.clearRect(0,0,tc.width,tc.height);

    const D = intersect(A,P,B,C);
    const E = intersect(B,P,C,A);
    const F = intersect(C,P,A,B);

    drawSeg(A,B,ctx);
    drawSeg(B,C,ctx);
    drawSeg(C,A,ctx);

    drawSeg(A,D,ctx,"#e74c3c");
    drawSeg(B,E,ctx,"#27ae60");
    drawSeg(C,F,ctx,"#8e44ad");

    drawDot(A,"A",ctx);
    drawDot(B,"B",ctx);
    drawDot(C,"C",ctx);
    drawDot(P,"P",ctx,true);

    document.getElementById("rBC").textContent =
        `${Math.round(dist(B,D))} : ${Math.round(dist(D,C))}`;
    document.getElementById("rCA").textContent =
        `${Math.round(dist(C,E))} : ${Math.round(dist(E,A))}`;
    document.getElementById("rAB").textContent =
        `${Math.round(dist(A,F))} : ${Math.round(dist(F,B))}`;
}

// Mouse
tc.addEventListener("mousedown",e=>{
    if(dist({x:e.offsetX,y:e.offsetY},P)<12) draggingP=true;
});
tc.addEventListener("mousemove",e=>{
    if(!draggingP) return;
    P = clampToTriangle({x:e.offsetX,y:e.offsetY});
    drawTriangle();
});
tc.addEventListener("mouseup",()=>draggingP=false);
tc.addEventListener("mouseleave",()=>draggingP=false);

// Helpers
function drawSeg(p,q,ctx,color="black"){
    ctx.beginPath();
    ctx.moveTo(p.x,p.y);
    ctx.lineTo(q.x,q.y);
    ctx.strokeStyle=color;
    ctx.lineWidth=2;
    ctx.stroke();
}
function drawDot(p,l,ctx,drag=false){
    ctx.beginPath();
    ctx.arc(p.x,p.y,8,0,Math.PI*2);
    ctx.fillStyle=drag?"#e74c3c":"#3498db";
    ctx.fill();
    ctx.fillStyle="black";
    ctx.fillText(l,p.x-5,p.y-12);
}
function gcd(a,b){ return b ? gcd(b,a%b) : Math.abs(a); }

drawTriangle();
drawLine();

</script>

</body>
</html>
