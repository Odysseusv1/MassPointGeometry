<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mass Point Geometry</title>

<style>
body {
    font-family: Arial, sans-serif;
    background: #f4f6f8;
    text-align: center;
    padding: 20px;
}

button {
    padding: 10px 18px;
    margin: 6px;
    font-size: 16px;
}

canvas {
    background: white;
    border: 2px solid #333;
    margin-top: 20px;
}

.page {
    display: none;
    max-width: 900px;
    margin: auto;
}

.page.active {
    display: block;
}

p, li {
    text-align: left;
    line-height: 1.6;
    font-size: 17px;
}

.info {
    margin-top: 20px;
    font-size: 17px;
}
</style>
</head>

<body>

<h1>My Nueva Project: Mass Point Geometry</h1>
<br><br>

<button onclick="go('about')">About</button>
<button onclick="go('why')">Explanation</button>
<button onclick="go('line')">Line Demo</button>
<button onclick="go('tri')">Triangle Demo</button>

<div id="about" class="page active">
<h2><b>Inspiration</b></h2>
<p>I was inspired by problem 24 from the 2019 AMC 8. In triangle ABC, point D divides side AC such that AD:DC = 1:2. Let E be the midpoint of BD and let F be the point of intersection of line BC and line AE. Given that the area of △ABC is 360, what is the area of triangle △EBF?</p>
<p>This problem initially seemed scary, and calculating areas directly felt complicated. Much later, I discovered that mass point geometry provided an elegant solution. By assigning masses to the vertices, the ratios and areas fell into place naturally. This experience showed me the power of choosing the right method for a problem, and it inspired me to build this interactive demonstration to help others understand and appreciate this beautiful technique.</p>
<img src = "amc2019prob24.jpg" alt="Problem 24" width="500" height="300">
<p>This problem showcases how mass point geometry can elegantly solve what otherwise might require coordinate geometry or complex area calculations.</p>
<h2><b>Process</b> </h2>
<p>I started by understanding mass point geometry through the AMC 8 problem. My process involved three key steps:</p>
<ol>
    <li><b>Research & Theory:</b> I studied how assigning masses to vertices creates balance points, and how ratios on sides relate inversely to masses.</li>
    <li><b>Interactive Visualization:</b> I built two demos—one showing how masses determine a point's position on a line segment, and another demonstrating how three concurrent cevians work in a triangle.</li>
    <li><b>Implementation:</b> I used HTML Canvas for rendering, mouse event listeners for interactivity, and mathematical functions to ensure geometric correctness.</li>
</ol>
<h2><b>What I learned</b></h2>
<p>Mass point geometry is a powerful technique for solving problems involving ratios and areas in triangles. It allows for elegant solutions by assigning "masses" to vertices, which then determine the positions of points on segments and the relationships between areas.</p>
<p>This process also taught me about coding and how to implement mathematical concepts in an interactive environment.</p>
<p>Also, I orginally programmed a part of this website with AI and I did not understand what the AI did, so I made my own version using simpler and more understandable concepts.</p>
</div>

<div id="line" class="page">
<h2>Mass Points on a Line</h2>
<p>Drag point <b>D</b> along segment <b>BC</b>.</p>

<canvas id="lc" width="600" height="200"></canvas>

<div class="info">
<p><b>BD : DC</b> = <span id="lr"></span></p>
<p><b>Mass at B</b> = <span id="mB"></span></p>
<p><b>Mass at C</b> = <span id="mC"></span></p>
<p><b>Mass at D</b> = <span id="mD"></span></p>
</div>
</div>

<div id="tri" class="page">
<h2>Triangle with Concurrent Cevians</h2>
<p>Drag point <b>P</b><br> <b>Disclosure:</b> Originally I used AI to write the part that ensures point P always stays inside the triangle. But I decided to rewrite it myself. As a result of this the function is much worse. The AI used barycentric coordinates which is an advanced technique to keep <b>P</b> in the triangle, but currently I use the equations of the lines to keep it within bounds.<b> So if point P escapes the triangle drag it back inside</b></p>

<canvas id="tc" width="600" height="420"></canvas>

<div class="info">
<p><b>BD : DC</b> = <span id="rBC"></span></p>
<p><b>CE : EA</b> = <span id="rCA"></span></p>
<p><b>AF : FB</b> = <span id="rAB"></span></p>
</div>
</div>

<div id="why" class="page">
<h2>Why This Is Guaranteed Correct</h2>
<h3>The Law of Lever</h3>
<p>Mass point geometry is based on the <b>law of lever</b> from physics. If two masses are balanced on a lever around a fulcrum, then:</p>
<img src = "lawoflever.gif" alt="Law of Lever" width="500" height="450">
<p style="text-align: center; font-size: 18px;"><b>Mass₁ × Distance₁ = Mass₂ × Distance₂</b> The distances are the distance from the mass to the fulcrum</p>
<p>If point <b>D</b> divides segment <b>BC</b> such that <b>BD : DC = m_C : m_B</b>, then assigning mass <b>m_B</b> at B and mass <b>m_C</b> at C makes D the balance point. The mass at the fulcrum D is simply <b>m_B + m_C</b>.</p>

<h3>Cevians and Concurrent Lines</h3>
<p>A <b>cevian</b> is a line segment from a vertex of a triangle to a point on the opposite side. When you assign masses to the three vertices A, B, and C, each side finds its balance point (fulcrum), and the three cevians from vertices through these balance points all meet at a single point—called the <b>concurrent point</b>.</p>
<p>This is guaranteed by <b>Ceva's Theorem</b>: if cevians AD, BE, and CF are concurrent at point P, then the product of the three ratios equals 1.</p>


<h3>Why It Works</h3>
<p>When you drag point P in the triangle demo, the interactive visualization assigns masses to A, B, and C such that:</p>
<ul>
    <li>Point D on BC balances masses at B and C</li>
    <li>Point E on CA balances masses at C and A</li>
    <li>Point F on AB balances masses at A and B</li>
</ul>
<p>Because the masses are consistent across all three vertices, all three cevians pass through the same point P. No special calculations are needed, the physics of the lever guarantees it.</p>

</div>


<button onclick="go('about')">About</button>
<button onclick="go('why')">Explanation</button>
<button onclick="go('line')">Line Demo</button>
<button onclick="go('tri')">Triangle Demo</button>

<script>
/* -------- Page Switching -------- */
function go(id) {
    document.querySelectorAll(".page").forEach(p => p.classList.remove("active"));
    document.getElementById(id).classList.add("active");
}

/* -------- Line Demo -------- */
const lc = document.getElementById("lc");
const lctx = lc.getContext("2d");

const B = { x: 100, y: 100 };
const C = { x: 500, y: 100 };
let D = { x: 300, y: 100 };

let dragD = false;

function drawLine() {
    lctx.clearRect(0, 0, lc.width, lc.height);

    seg(B, C, lctx);
    dot(B, "B", lctx);
    dot(C, "C", lctx);
    dot(D, "D", lctx, true);

    const BD = D.x - B.x;
    const DC = C.x - D.x;
    const g = gcd(BD, DC);

    document.getElementById("lr").textContent = `${BD/g} : ${DC/g}`;
    document.getElementById("mB").textContent = DC/g;
    document.getElementById("mC").textContent = BD/g;
    document.getElementById("mD").textContent = (BD + DC) / g;
}

lc.addEventListener("mousedown", e => {
    if (Math.abs(e.offsetX - D.x) < 10) dragD = true;
});

lc.addEventListener("mousemove", e => {
    if (!dragD) return;
    D.x = Math.max(B.x, Math.min(C.x, e.offsetX));
    drawLine();
});

lc.addEventListener("mouseup", () => dragD = false);

/* -------- Triangle Demo -------- */
const tc = document.getElementById("tc");
const ctx = tc.getContext("2d");

const A = { x: 300, y: 60 };
const B2 = { x: 120, y: 340 };
const C2 = { x: 480, y: 340 };

let P = { x: 300, y: 220 };
let dragP = false;

function d(p, q) {
    return Math.hypot(p.x - q.x, p.y - q.y);
}

// Keep P inside triangle
function clamp(p) {
    const bcSlope = (C2.y - B2.y) / (C2.x - B2.x);
    const lineY = B2.y + bcSlope * (p.x - B2.x);
    
    // clamp to triangle cuz of line equations
    let clamped = { ...p };
    
    // abLine A --> B2
    const abSlope = (B2.y - A.y) / (B2.x - A.x);
    const abLine = (x) => A.y + abSlope * (x - A.x);
    
    // acLine A --> C2
    const acSlope = (C2.y - A.y) / (C2.x - A.x);
    const acLine = (x) => A.y + acSlope * (x - A.x);
    
    // bcLine B2 --> C2
    const bcLine = (x) => B2.y + bcSlope * (x - B2.x);
    
    if (clamped.y < abLine(clamped.x)) 
        clamped.y = abLine(clamped.x);
    if (clamped.y < acLine(clamped.x)) 
        clamped.y = acLine(clamped.x);
    if (clamped.y > bcLine(clamped.x)) 
        clamped.y = bcLine(clamped.x);
    
    return clamped;
}

// Line intersection
function ix(U, V, X, Y) {
    const a1 = V.y - U.y;
    const b1 = U.x - V.x;
    const c1 = a1*U.x + b1*U.y;

    const a2 = Y.y - X.y;
    const b2 = X.x - Y.x;
    const c2 = a2*X.x + b2*X.y;

    const det = a1*b2 - a2*b1;

    return {
        x: (b2*c1 - b1*c2) / det,
        y: (a1*c2 - a2*c1) / det
    };
}

function drawTri() {
    ctx.clearRect(0, 0, tc.width, tc.height);

    const D2 = ix(A, P, B2, C2);
    const E = ix(B2, P, C2, A);
    const F = ix(C2, P, A, B2);

    seg(A, B2, ctx);
    seg(B2, C2, ctx);
    seg(C2, A, ctx);

    seg(A, D2, ctx, "#e74c3c");
    seg(B2, E, ctx, "#27ae60");
    seg(C2, F, ctx, "#8e44ad");

    dot(A, "A", ctx);
    dot(B2, "B", ctx);
    dot(C2, "C", ctx);
    dot(P, "P", ctx, true);

    document.getElementById("rBC").textContent =
        `${Math.round(d(B2, D2))} : ${Math.round(d(D2, C2))}`;
    document.getElementById("rCA").textContent =
        `${Math.round(d(C2, E))} : ${Math.round(d(E, A))}`;
    document.getElementById("rAB").textContent =
        `${Math.round(d(A, F))} : ${Math.round(d(F, B2))}`;
}

tc.addEventListener("mousedown", e => {
    if (d({ x: e.offsetX, y: e.offsetY }, P) < 12) dragP = true;
});

tc.addEventListener("mousemove", e => {
    if (!dragP) return;
    P = clamp({ x: e.offsetX, y: e.offsetY });
    drawTri();
});

tc.addEventListener("mouseup", () => dragP = false);
tc.addEventListener("mouseleave", () => dragP = false);

// helperss
function seg(p, q, ctx, col = "black") {
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(q.x, q.y);
    ctx.strokeStyle = col;
    ctx.lineWidth = 2;
    ctx.stroke();
}

function dot(p, t, ctx, drag = false) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
    ctx.fillStyle = drag ? "#e74c3c" : "#3498db";
    ctx.fill();
    ctx.fillStyle = "black";
    ctx.fillText(t, p.x - 5, p.y - 12);
}

function gcd(a, b) {
    return b ? gcd(b, a % b) : Math.abs(a);
}

/* Initial draw */
drawLine();
drawTri();
</script>

</body>
</html>
